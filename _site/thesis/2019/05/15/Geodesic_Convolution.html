<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Geodesic Convolution</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <head>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber:     "all" } } }); </script>
   <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
       }
     });
   </script>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"     type="text/javascript"></script>
</head>

  </head>
    <body>
      <header class="site-header">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">MvO</a>
  
    
      <nav class="site-nav">
        <!--<input type="checkbox" id="nav-trigger" class="nav-trigger" />-->
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/about.html">About</a>
            
          
            
            
            <a class="page-link" href="/">Projects</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/thesis.html">Thesis</a>
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>

      <div class="page-content">
        <div class="wrapper">
      <h1>Geodesic Convolution</h1>
<p>
  15 May 2019
</p>

<p>In this post shows an idea to generalise convolutional layers from images (functions on $\mathbb{R}^2$) to functions on triangulated manifolds. It will focus on the convolution of a kernel with a function. In a future post we will address the problem of input channels and output channels. The ideas presented here are based on <a href="https://www.cv-foundation.org/openaccess/content_iccv_2015_workshops/w22/papers/Masci_Geodesic_Convolutional_Neural_ICCV_2015_paper.pdf">this paper</a>.</p>

<hr />

<p>Post Structure:</p>
<ul>
  <li>Theory: introducing the idea and explaining the motivation</li>
  <li>The Kernel: The kernel used in the examples</li>
  <li>Example 1: The Sphere</li>
  <li>Example 2: The Body</li>
</ul>

<hr />

<h2 id="theory">Theory</h2>

<p>The idea behind standard convolutional layer in a neural network is to extract local information about the function/image. Typically this is done using weights from a kernel. This local information can become more and more abstract by adding multiple convolutional layers after one another. The way of extracting information is the same on the entire image, using this type of weight sharing greatly reduces the dimension of the weight space, and should make training a model simpler.</p>

<p>If the input is an image, then the network takes a local weighted average around a point. This operation is represented by the convolution operator.</p>

<script type="math/tex; mode=display">\begin{align*}
f\star g (x) = \sum_{n}f(n)g(x-n)
\end{align*}</script>

<p>In the case of the image, the underlying structure is flat $2$ dimesnional euclidean space, and the pixels are spaced out evenly. In the case of a triangulated surface with a function, one cannot use this definition of the convolution, e.g. substraction is not defined on the triangulated manifold.</p>

<p>Still the idea implemented here is the same, the layer should extract local information of the function around a points. Similar as in the article we explain the idea of an patch and then define the Geodesic Convolution.</p>

<hr />

<h2 id="patch">Patch</h2>

<p>Around each point we will have a neighborhood that is equivalent to a disk. On this disk we can define our kernel and then define the convolution by using this map from the neighborhood to the disk.</p>

<p>More formally, define the set</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
 B_r(x):= \{ y \in M | d(x,y) < r \}
\end{align*} %]]></script>

<p>the set of all point such that the geodesic distance is smaller than $r$. Additionally we can compute the actual geodesic between the points $y$ and $x$. These geodesics have a representative tangent vector in the tangent space $T_xM$. After choosing a basis of the tangent space we can calculate the angles of the vectors denote this angle as $\Theta_x(y)$. This way we can make a function</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\phi_x & : B_r(x) \to D_r\\
y & \mapsto (d(x,y), \Theta_x(y))
\end{align*} %]]></script>

<p>Note that this definition of a patch only makes sense if $r$ is small enough, such that $B_r(x)$ is actually topological equivalent to a disk. This makes sure that the cut locus is not represented in the disk, meaning the function is continuous.</p>

<p>Then the geodesic convolutional operator is defined as $f\star g = \sum_{\rho, \theta} f(\phi_x^{-1}(\rho,\theta))k(\rho, \theta)$</p>

<hr />

<h3 id="tangent-vectors">Tangent Vectors</h3>

<p>Given a triangulated surface, how does one speak of a tangent space at a point, this point where triangles come together, will not have a natural tangent space. We overcome this issue, by mapping the neighborhood to $\mathbb{R}^2$ by keeping the ratio of triangle angles the same.</p>

<hr />

<h3 id="hardbinning">Hardbinning</h3>

<p>The function is only defined on the vertices of the manifold, then $f(\phi_x^{-1}(\rho,\theta))$ might not always be well defined. Computationally we bin each point in $B_r(x)$ into an angular bin and a radial bin. Then the kernel is a matrix with weights for each bin. Then we take the local average, if the mesh does not have a representative point for a bin then we the value is assumed to be zero.</p>

<hr />

<h3 id="softbinning">Softbinning</h3>

<p>As a soft binning principle, one can smooth out the mapped points on the disk, this will make them contribute to bins that potentialy didnâ€™t have a member. This smoothing out principle will potentially reduces the importance of the triangulation. Althoug smoothing out too much might decrease the power of the convolution in later stadia of the network.</p>

<hr />

<h3 id="bin-normalisation">Bin normalisation</h3>

<p>If the vertices are not spread out nice and evenly, taking an unweighted sum might heavely favor a bin if it contains a lot of vertices. Or similarly, a vertex in an area that is sparsely populated will not obtain as big a value as a point which is densely populated. Hence we use bin normalisation. Where each bin has at most weight $1$ evenly spread out among its members. simmilarly on a path we weight the num by the total number of vertices.</p>

<hr />

<h1 id="notes">Notes</h1>

<p>This method has a drawback, namely we have to choose a basis. Therefor the orientation of the patch is not consistant. The reason why we have to choose a basis is because there is not a natural way of making a mapping between two points.
This is something the image convolution did have. Furthermore, with image convolutions one can set stepsizes to reduce the height and width of an image, this does not have an equivalent in the triangulated case.</p>

<p>What can also be regarded as a drawback is the creation of the patches, we assume the triangulated data is behaving. This might limit the generalisation.</p>

<hr />

<h3 id="code">Code</h3>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">vtki</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'..'</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">plyfile</span> <span class="kn">import</span> <span class="n">PlyData</span><span class="p">,</span> <span class="n">PlyElement</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">vtki</span> <span class="kn">import</span> <span class="n">PolyData</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="c"># Home made modules</span>
<span class="kn">from</span> <span class="nn">modules.trimesh</span> <span class="kn">import</span> <span class="n">trimesh</span>
<span class="kn">from</span> <span class="nn">modules.fast_marching_method</span> <span class="kn">import</span> <span class="n">FMM</span>
<span class="kn">from</span> <span class="nn">modules.gradient_walk.linear_walk</span> <span class="kn">import</span> <span class="n">LinearWalk</span>
<span class="kn">from</span> <span class="nn">modules.adj_matrix</span> <span class="kn">import</span> <span class="n">adjacency_matrix_fmm</span>
<span class="kn">from</span> <span class="nn">modules.geometry_functions</span> <span class="kn">import</span> <span class="n">laplace_beltrami_eigenfunctions</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="o">%</span><span class="n">load_ext</span> <span class="n">autoreload</span>
<span class="o">%</span><span class="n">autoreload</span> <span class="mi">2</span>
</code></pre></div></div>

<p>A function to load the mesh</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">trimesh_from_ply</span><span class="p">(</span><span class="n">f_name</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">PlyData</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
    
    <span class="n">data_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s">'vertex'</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
    <span class="n">data_tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">'face'</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">'vertex_indices'</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">trimesh</span><span class="p">(</span><span class="n">data_vert</span><span class="p">,</span><span class="n">data_tri</span><span class="p">)</span>

<span class="c"># Bin parameter</span>
<span class="n">p_bins</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">t_bins</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div></div>

<hr />

<h1 id="the-kernel">The kernel</h1>

<p>Since this method chooses an orientation of the kernel randomly, we take a kernel that is rotation invariant. The kernel is the gaussian kernel.</p>

<p>Below we construct the kernel</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Some small functions</span>
<span class="n">sigma_p</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">p_exp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma_p</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">p_trans</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">/</span><span class="n">p_bins</span>
<span class="n">t_trans</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">t_bins</span>

<span class="k">def</span> <span class="nf">plot_disk</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">"polar"</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make the kernel and plot it</span>
<span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">p_bins</span><span class="p">)</span>
<span class="n">azm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">azm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_kernel</span><span class="p">(</span><span class="n">p_bins</span><span class="p">,</span><span class="n">t_bins</span><span class="p">):</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">t_bins</span><span class="p">,</span> <span class="n">p_bins</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_bins</span><span class="p">):</span>
        <span class="n">r_1</span> <span class="o">=</span> <span class="n">p_trans</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">p_exp</span><span class="p">(</span><span class="n">r_1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_bins</span><span class="p">):</span>
            <span class="n">kernel</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">kernel</span><span class="o">/</span><span class="n">kernel</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>

<span class="n">kernel</span> <span class="o">=</span> <span class="n">make_kernel</span><span class="p">(</span><span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">)</span>
<span class="n">plot_disk</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">r</span> <span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_6_1.png" alt="png" /></p>

<hr />

<h1 id="example-1-the-sphere">Example 1: The Sphere</h1>

<p>In this example we take the isohedral sphere.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># open the mesh</span>
<span class="n">file_sphere</span> <span class="o">=</span> <span class="s">'../test_data/sphere_iso_6c.ply'</span>
<span class="n">sphere</span> <span class="o">=</span> <span class="n">trimesh_from_ply</span><span class="p">(</span><span class="n">file_sphere</span><span class="p">)</span>
</code></pre></div></div>

<p>The below function creates the adjacency matrix:
The innerworking can be described as</p>
<ul>
  <li>for each vertex do
    <ul>
      <li>find the points in a certain geodesic radius</li>
      <li>find for each of these points the geodesic</li>
      <li>bin each point in a angular and radial bin</li>
    </ul>
  </li>
  <li>return the matrix</li>
</ul>

<p>Right now the matrix has dimension NxNxPxT, where N are the number of vertices P the number of radial bins and T the number of angular bins.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make the adjacency matrix</span>
<span class="n">adj_sphere</span> <span class="o">=</span> <span class="n">adjacency_matrix_fmm</span><span class="p">(</span><span class="n">sphere</span><span class="p">,</span> <span class="n">p_max</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">p_bins</span> <span class="o">=</span> <span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span> <span class="o">=</span> <span class="n">t_bins</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 642/642 [03:10&lt;00:00,  3.49it/s]
</code></pre></div></div>

<h2 id="sparse-matrices">Sparse Matrices</h2>

<p>The creation of the adjacency matrix can be done as a preprocessing step. Now the adjacency matrix can become quite big, while a lot of entries are actually zero. Thus it makes sense to use sparse matrices, in this data structure one only remembers the rowpointers, columns and the data point. This saves significant memory if the matrix is sparse, also certain calculations can be done more efficiently.</p>

<p>Thus since at a later stage the adjacency matrix is represented as a sparse matrix, we cast the matrix to a sparse matrix. A sparse matrix has to have a 2 dimensional stucture, hence the reshape.</p>

<hr />

<p>Below some extra fuctions that help handle the sparse matrices.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bin_normalisation</span><span class="p">(</span><span class="n">sp_mat</span><span class="p">):</span>
    <span class="s">'''
    Normalize devide the vertex by the total number of vertices in the bin.
    Then also devide by the total number of points in the patch.
    '''</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">indptr</span>
    
    <span class="n">res1</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">res2</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">ind</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">r</span><span class="p">]:</span><span class="n">row</span><span class="p">[</span><span class="n">r</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">col</span> <span class="o">%</span> <span class="p">(</span><span class="n">p_bins</span><span class="o">*</span><span class="n">t_bins</span><span class="p">)</span>
        
        <span class="n">num_bins</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">bins</span><span class="p">))</span>
        <span class="n">count_bin</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">bins</span><span class="p">:</span>
            <span class="n">res1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">count_bin</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">res2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">num_bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">res2</span><span class="p">)),</span><span class="n">ind</span><span class="p">,</span> <span class="n">row</span><span class="p">))</span> 

<span class="k">def</span> <span class="nf">sparse_reshape</span><span class="p">(</span><span class="n">sp_mat</span><span class="p">):</span>
    <span class="s">'''
    The sparse matrix is 2 dimensional, given the number of bins
    we can find which vertex belongs where
    '''</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">indices</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">indptr</span>
    
    <span class="c"># Find which bins the points belong to. </span>
    <span class="n">sp_t</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">%</span> <span class="n">t_bins</span> <span class="c"># angle</span>
    <span class="n">sp_p</span> <span class="o">=</span> <span class="p">(</span> <span class="n">ind</span> <span class="o">%</span> <span class="p">(</span><span class="n">t_bins</span><span class="o">*</span><span class="n">p_bins</span><span class="p">))</span><span class="o">//</span><span class="n">t_bins</span> <span class="c"># radius</span>
    <span class="n">sp_c</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">//</span> <span class="p">(</span><span class="n">t_bins</span><span class="o">*</span><span class="n">p_bins</span><span class="p">)</span> <span class="c">#column</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">row</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 
    <span class="n">sp_r</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">diff</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">diff</span><span class="p">[</span><span class="n">i</span><span class="p">])]</span> <span class="c">#row</span>
    
    <span class="k">return</span> <span class="n">sp_r</span><span class="p">,</span> <span class="n">sp_c</span><span class="p">,</span> <span class="n">sp_p</span><span class="p">,</span> <span class="n">sp_t</span>
    
<span class="k">def</span> <span class="nf">make_conv_matrix</span><span class="p">(</span><span class="n">sp_mat</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="s">'''
    Combine the adjacency matrix with the kernel to make the convolution matrix.
    '''</span>
    <span class="c"># Read lists from the sparse matrix</span>
    <span class="n">num_vert</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    
    <span class="n">sp_r</span><span class="p">,</span> <span class="n">sp_c</span><span class="p">,</span> <span class="n">sp_p</span><span class="p">,</span> <span class="n">sp_t</span> <span class="o">=</span> <span class="n">sparse_reshape</span><span class="p">(</span><span class="n">sp_mat</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="nb">float</span><span class="p">)</span>
    
    <span class="c"># Find the weights of each bin and multiply by the amount a vertex should contribute. </span>
    <span class="n">sp_d</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indptr</span> <span class="o">=</span> <span class="n">sp_mat</span><span class="o">.</span><span class="n">indptr</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">indptr</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">indptr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">rel</span> <span class="o">=</span> <span class="n">kernel</span><span class="p">[</span><span class="n">sp_t</span><span class="p">[</span><span class="n">sl</span><span class="p">],</span><span class="n">sp_p</span><span class="p">[</span><span class="n">sl</span><span class="p">]]</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
        <span class="n">sp_d</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rel</span><span class="o">/</span><span class="n">rel</span><span class="o">.</span><span class="nb">sum</span><span class="p">())</span>


    <span class="c"># Cast this again to a sparse matrix</span>
    <span class="n">conv_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">coo_matrix</span><span class="p">((</span><span class="n">sp_d</span><span class="p">,</span> <span class="p">(</span><span class="n">sp_r</span><span class="p">,</span><span class="n">sp_c</span><span class="p">)),</span> <span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">num_vert</span><span class="p">,</span><span class="n">num_vert</span><span class="p">))</span>
        
    <span class="k">return</span> <span class="n">conv_mat</span>
    
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make a sparse matrix out of the adjacenct matrix. </span>
<span class="c"># And normalize it.</span>
<span class="n">sparse_sphere</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj_sphere</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">sparse_sphere</span> <span class="o">=</span> <span class="n">bin_normalisation</span><span class="p">(</span><span class="n">sparse_sphere</span><span class="p">)</span>

<span class="c"># Make the convolution matrix</span>
<span class="n">conv_sphere</span> <span class="o">=</span> <span class="n">make_conv_matrix</span><span class="p">(</span><span class="n">sparse_sphere</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Our function has value 1 on a vertex and is zero otherwise.</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
<span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># The convoluted function</span>
<span class="n">conv_func</span> <span class="o">=</span> <span class="n">conv_sphere</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Initial function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Convoluted function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">conv_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_16_0.png" alt="png" /></p>

<h1 id="example-2-the-body">Example 2: The body</h1>

<p>This example show a body traingulation of from the <a href="http://faust.is.tue.mpg.de">FAUST</a> dataset. This triangulation is a bit more irregular than the sphere.</p>

<p>We have already precomputed the adjacency matrix (hardbinning), to calculate this would take roughly one hour. To make the adjacency matrix we have used the following settings:</p>
<ul>
  <li><code class="highlighter-rouge">p_max = 0.03</code></li>
  <li><code class="highlighter-rouge">t_bins = 16</code></li>
  <li><code class="highlighter-rouge">p_bins = 5</code></li>
</ul>

<p>The function on which we will take the convolution is the an eigenvector of the laplace beltrami operator with added noise. The kernel will again be the gaussian kernel, ideally this kernel should be able to help with the noise that we added.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file_adj</span> <span class="o">=</span> <span class="s">'../test_data/tr_reg_004_raw.npz'</span>
<span class="n">file_body</span> <span class="o">=</span> <span class="s">'../test_data/tr_reg_004.ply'</span>

<span class="n">p_bins</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">t_bins</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">adj_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">file_adj</span><span class="p">)</span>
<span class="n">adj_body</span> <span class="o">=</span> <span class="n">bin_normalisation</span><span class="p">(</span><span class="n">adj_mat</span><span class="p">)</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">trimesh_from_ply</span><span class="p">(</span><span class="n">file_body</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<p>Making a new kernel with the new parameters, we will take a more interesting function as well.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># get a laplace function</span>
<span class="n">val</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">laplace_beltrami_eigenfunctions</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">k</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>

<span class="c"># To make sure we get the same result</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">laplace_func_orig</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[:,</span><span class="mi">20</span><span class="p">]</span>
<span class="n">laplace_func</span> <span class="o">=</span> <span class="n">laplace_func_orig</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span> <span class="o">=</span> <span class="o">.</span><span class="mi">15</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">laplace_func_orig</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Original function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Noisy function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_21_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">kernel</span> <span class="o">=</span> <span class="n">make_kernel</span><span class="p">(</span><span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">)</span>
<span class="n">conv_body</span> <span class="o">=</span> <span class="n">make_conv_matrix</span><span class="p">(</span><span class="n">adj_body</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>

</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The convoluted function</span>
<span class="n">conv_func</span> <span class="o">=</span> <span class="n">conv_body</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">laplace_func</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="softbinning-1">Softbinning</h2>

<p>For the soft binning we smooth out the projected point on the disk, so that is also contributes to other bins. This is also done using a gaussian blur.</p>

<p>Because we use a gaussian blur to smooth out points, and later use a gaussian filter, we do not expect to see a huge difference. Given a different filter, one might expect to see beter results.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sigma_p</span> <span class="o">=</span> <span class="mi">1</span>

<span class="n">rad</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p_bins</span><span class="p">))</span>
<span class="n">azm</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">t_bins</span><span class="p">))</span>
<span class="n">r_o</span><span class="p">,</span> <span class="n">th_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">azm</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">p_trans</span><span class="p">(</span><span class="n">r_o</span><span class="p">),</span> <span class="n">t_trans</span><span class="p">(</span><span class="n">th_o</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">radial_smoothing</span><span class="p">(</span><span class="n">r_0</span><span class="p">,</span> <span class="n">t_0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">r_0</span><span class="p">,</span> <span class="n">t_0</span> <span class="o">=</span> <span class="n">p_trans</span><span class="p">(</span><span class="n">r_0</span><span class="p">),</span> <span class="n">t_trans</span><span class="p">(</span><span class="n">t_0</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">r_0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">t_0</span><span class="p">)],</span> <span class="p">[</span><span class="n">r_0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t_0</span><span class="p">)]])</span>
    
    <span class="n">z</span> <span class="o">=</span> <span class="n">p_exp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t_bins</span><span class="p">,</span> <span class="n">p_bins</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">z</span><span class="o">/</span><span class="n">z</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">soft_bins</span><span class="p">(</span><span class="n">adj_body</span><span class="p">,</span> <span class="n">p_bins</span> <span class="o">=</span> <span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span> <span class="o">=</span> <span class="n">t_bins</span><span class="p">):</span>
    <span class="n">sp_r</span><span class="p">,</span> <span class="n">sp_c</span><span class="p">,</span> <span class="n">sp_p</span><span class="p">,</span> <span class="n">sp_t</span> <span class="o">=</span> <span class="n">sparse_reshape</span><span class="p">(</span><span class="n">adj_body</span><span class="p">)</span>
    
    <span class="n">num_vert</span> <span class="o">=</span> <span class="n">adj_body</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">adj_body</span><span class="o">.</span><span class="n">data</span>
    
    <span class="n">ind_range</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_bins</span><span class="o">*</span><span class="n">p_bins</span><span class="p">)])</span>
    <span class="n">new_ptr</span><span class="p">,</span> <span class="n">new_i</span><span class="p">,</span> <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[]</span>
    <span class="n">prev_row</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sp_r</span><span class="p">))):</span>
        <span class="k">if</span> <span class="n">sp_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">prev_row</span><span class="p">:</span>
            <span class="n">prev_row</span> <span class="o">=</span> <span class="n">sp_r</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">ptr</span> <span class="o">=</span> <span class="n">i</span><span class="o">*</span><span class="n">t_bins</span><span class="o">*</span><span class="n">p_bins</span>
            <span class="n">new_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        
        <span class="n">new_data</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">radial_smoothing</span><span class="p">(</span><span class="n">sp_p</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="n">sp_t</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">new_i</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">sp_c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">t_bins</span><span class="o">*</span><span class="n">p_bins</span><span class="o">+</span> <span class="n">ind_range</span><span class="p">))</span>
    <span class="n">new_ptr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">new_data</span><span class="p">))</span> 
    <span class="k">return</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">((</span><span class="n">new_data</span><span class="p">,</span> <span class="n">new_i</span><span class="p">,</span> <span class="n">new_ptr</span><span class="p">))</span>
        
        
        
        
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sparse_body</span> <span class="o">=</span> <span class="n">soft_bins</span><span class="p">(</span><span class="n">adj_body</span><span class="p">)</span>
<span class="n">conv_smooth</span> <span class="o">=</span> <span class="n">make_conv_matrix</span><span class="p">(</span><span class="n">sparse_body</span><span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100%|â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ| 230596/230596 [00:28&lt;00:00, 8159.45it/s]
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The convoluted function</span>
<span class="n">conv_func_smooth</span> <span class="o">=</span> <span class="n">conv_smooth</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">laplace_func</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<p>If we plot the convoluted functions, there is not much difference between the hardbinned and the softbinned. This might be because the triangulation around a point is fine grained enough. But also because the kernel is a gaussian blur, this will hide the effect of the smoothing out of a point.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>

<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Original function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Noisy function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Hard bin'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">conv_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Soft bin'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">conv_func_smooth</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_30_0.png" alt="png" /></p>



        </div>
      </div>

    </body>
</html>
