<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Geodesic Convolution</title>
    <link rel="stylesheet" href="/assets/css/styles.css">
    <head>
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ TeX: { equationNumbers: { autoNumber:     "all" } } }); </script>
   <script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [ ['$','$'], ["\\(","\\)"] ],
         processEscapes: true
       }
     });
   </script>
     <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"     type="text/javascript"></script>
</head>

  </head>
    <body>
      <header class="site-header">

  <div class="wrapper">
    
    
    <a class="site-title" href="/">MvO</a>
  
    
      <nav class="site-nav">
        <!--<input type="checkbox" id="nav-trigger" class="nav-trigger" />-->
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
              <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
              <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger">
          
            
            
            <a class="page-link" href="/about.html">About</a>
            
          
            
            
            <a class="page-link" href="/">Projects</a>
            
          
            
            
          
            
            
            <a class="page-link" href="/thesis.html">Thesis</a>
            
          
            
            
          
        </div>
      </nav>
    
  </div>
</header>

      <div class="page-content">
        <div class="wrapper">
      <h1>Geodesic Convolution</h1>
<p>
  15 May 2019
</p>

<p>This post shows an idea to generalise convolutional layers from images (functions on $\mathbb{R}^2$) to functions on triangulated manifolds.</p>

<p>It will focus on the convolution of a kernel with a function. In a future post we will address the problem of input channels and output channels. The ideas presented here are based on the papers <a href="https://www.cv-foundation.org/openaccess/content_iccv_2015_workshops/w22/papers/Masci_Geodesic_Convolutional_Neural_ICCV_2015_paper.pdf">Geodesic Convolutional Neural Networks on Riemannian Manifolds</a> and <a href="https://www.tau.ac.il/~roeelitm/KokBroLitBroCVPR12.pdf">Intrinsic shape context descriptors for deformable shapes</a>.</p>

<hr />
<p>Post Structure:</p>
<ul>
  <li>Theory: introducing the idea and explaining the motivation</li>
  <li>The Kernel: The kernel used in the examples</li>
  <li>Example 1: The Sphere</li>
  <li>Example 2: The Body</li>
</ul>

<hr />

<p>The idea behind standard convolutional layer in a neural network is to extract local information about the function/image. Typically this is done using weights from a kernel. This local information can become more and more abstract by adding multiple convolutional layers after one another. The way of extracting information is the same on the entire image, using this type of weight sharing greatly reduces the dimension of the weight space, and should make training a model simpler.</p>

<p>If the input is an image, then the network takes a local weighted average around a point. This operation is represented by the convolution operator.
<script type="math/tex">\begin{align*}
f\star g (x) = \sum_{n}f(n)g(x-n)
\end{align*}</script>
In the case of the image, the underlying structure is flat $2$ dimesnional euclidean space, and the pixels are spaced out evenly. In the case of a triangulated surface with a function, one cannot use this definition of the convolution, e.g. substraction is not defined on the triangulated manifold.</p>

<p>Still the idea implemented here is the same, the layer should extract local information of the function around a points. Similar as in the article we explain the idea of an patch and then define the Geodesic Convolution.</p>

<hr />

<h2 id="patch">Patch</h2>

<p>Around each point we will have a neighborhood that is equivalent to a disk. On this disk we can define our kernel and then define the convolution by using this map from the neighborhood to the disk.</p>

<p>More formally, define the set</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
B_r(x):\{ y \in M | d(x,y) < r \} 
\end{align*} %]]></script>

<p>the set of all point such that the geodesic distance is smaller than $r$. Additionally we can compute the actual geodesic between the points $y$ and $x$. These geodesics have a representative tangent vector in the tangent space $T_xM$. After choosing a basis of the tangent space we can calculate the angles of the vectors denote this angle as $\Theta_x(y)$. This way we can make a function</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
\phi_x & : B_r(x) \to D_r\\
y & \mapsto (d(x,y), \Theta_x(y))
\end{align*} %]]></script>

<p>Note that this definition of a patch only makes sense if $r$ is small enough, such that $B_r(x)$ is actually topological equivalent to a disk. This makes sure that the cut locus is not represented in the disk, meaning the function approximates a continuous function.</p>

<p>Then the geodesic convolutional operator is defined as $(f\star k) (x) = \sum_{\rho, \theta} d_xf(\rho,\theta)k(\rho, \theta)$ with $d_xf(\rho,\theta):= f(\phi_x^{-1}(\rho,\theta)$.</p>

<h3 id="tangent-vectors">Tangent Vectors</h3>

<p>Given a triangulated surface, how does one speak of a tangent space at a point, this point where triangles come together, will not have a natural tangent space. We overcome this issue, by mapping the neighborhood to $\mathbb{R}^2$ by keeping the ratio of triangle angles the same.</p>

<h3 id="interpolation">Interpolation</h3>

<p>The function is only defined on the vertices of the manifold, then $D_xf(\rho,\theta):= f(\phi_x^{-1}(\rho,\theta))$ might not always be well defined.</p>

<p>Therefor we change the definition slightly to an expected value</p>

<script type="math/tex; mode=display">% <![CDATA[
\begin{align*}
D_xf(\rho,\theta) = \mathbb{E}[d_xf(\rho,\theta)] & = \int_{\rho', \theta'} p_{\rho,\theta}(\rho',\theta') d_xf(\rho', \theta') d\rho' d\theta' \\
& = \int_y p_{\rho,\theta}(y) f(y) dy \\
& = \sum_y p_{\rho,\theta}(y) f(y) \mu(y)
\end{align*} %]]></script>

<p>The measure $\mu$ is the vertex area, this is defined as a third of the sum of the areas of adjacent triangles.</p>

<p>As probability function we use the $\phi_x$ to obtain $\rho_y, \theta_y$, transforming this to euclidean coordinates we can calculate the distance between the point and $\rho, \theta$, denoted as $d_{\rho,\theta}(y)$, then the probability distribution is defined as</p>

<script type="math/tex; mode=display">\begin{align*}
p_{\rho,\theta}(x) = \frac{\exp(-\frac{d_{\rho,\theta}(x)^2}{2\sigma^2})}{\sum_y \exp(-\frac{d_{\rho,\theta}(y)^2}{2\sigma^2})}
\end{align*}</script>

<p>The $\sigma$ parameter is chosen to be $0.3$, simply because is gives visually pleasing results.</p>

<p>Then final version of the geodesic convolutional operator is defined as</p>

<script type="math/tex; mode=display">\begin{align*}
(f\star k)(x) = \sum_{\rho, \theta} D_xf(\rho,\theta)k(\rho, \theta)
\end{align*}</script>

<h1 id="notes">Notes</h1>

<p>This method has a drawback, namely we have to choose a basis. Therefor the orientation of the patch is not consistant. The reason why we have to choose a basis is because there is not a natural way of making a mapping between two points. This is something the image convolution did have. Furthermore, with image convolutions one can set stepsizes to reduce the height and width of an image, this does not have an equivalent in the triangulated case.</p>

<p>This method is dependent on a couple choices, and more research needs to be done to find the best. The choices being</p>
<ul>
  <li>The creation of the patches.</li>
  <li>The interpolation of the function</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">vtki</span>
<span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s">'..'</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="n">plt</span>

<span class="kn">from</span> <span class="nn">plyfile</span> <span class="kn">import</span> <span class="n">PlyData</span><span class="p">,</span> <span class="n">PlyElement</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">vtki</span> <span class="kn">import</span> <span class="n">PolyData</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="c"># Home made modules</span>
<span class="kn">from</span> <span class="nn">modules.trimesh</span> <span class="kn">import</span> <span class="n">trimesh</span>
<span class="kn">from</span> <span class="nn">modules.fast_marching_method</span> <span class="kn">import</span> <span class="n">FMM</span>
<span class="kn">from</span> <span class="nn">modules.gradient_walk.linear_walk</span> <span class="kn">import</span> <span class="n">LinearWalk</span>
<span class="kn">from</span> <span class="nn">modules.adj_matrix</span> <span class="kn">import</span> <span class="n">adjacency_matrix_fmm</span>
<span class="kn">from</span> <span class="nn">modules.geometry_functions</span> <span class="kn">import</span> <span class="n">laplace_beltrami_eigenfunctions</span>

<span class="o">%</span><span class="n">matplotlib</span> <span class="n">inline</span>
<span class="o">%</span><span class="n">load_ext</span> <span class="n">autoreload</span>
<span class="o">%</span><span class="n">autoreload</span> <span class="mi">2</span>
</code></pre></div></div>

<p>A function to load the mesh</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">trimesh_from_ply</span><span class="p">(</span><span class="n">f_name</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">PlyData</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">f_name</span><span class="p">)</span>
    
    <span class="n">data_vert</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span> <span class="k">for</span> <span class="n">vertex</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="s">'vertex'</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">])</span>
    <span class="n">data_tri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s">'face'</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s">'vertex_indices'</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">trimesh</span><span class="p">(</span><span class="n">data_vert</span><span class="p">,</span><span class="n">data_tri</span><span class="p">)</span>

<span class="c"># Bin parameter</span>
<span class="n">p_bins</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">t_bins</span> <span class="o">=</span> <span class="mi">16</span>
</code></pre></div></div>

<hr />

<h1 id="the-kernel">The kernel</h1>

<p>Since this method chooses an orientation of the kernel randomly, we take a kernel that is rotation invariant. The kernel is the gaussian kernel.</p>

<p>Below we construct the kernel</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Some small functions</span>
<span class="n">p_exp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">p_trans</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">:</span> <span class="n">r</span><span class="o">/</span><span class="n">p_bins</span>
<span class="n">t_trans</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">t_bins</span>

<span class="k">def</span> <span class="nf">plot_disk</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>
    <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="n">projection</span><span class="o">=</span><span class="s">"polar"</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make the kernel and plot it</span>
<span class="n">rad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">p_bins</span><span class="p">)</span>
<span class="n">azm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">)</span>
<span class="n">r</span><span class="p">,</span> <span class="n">th</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rad</span><span class="p">,</span> <span class="n">azm</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">make_kernel</span><span class="p">(</span><span class="n">p_bins</span><span class="p">,</span><span class="n">t_bins</span><span class="p">):</span>
    <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">t_bins</span><span class="p">,</span> <span class="n">p_bins</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">p_bins</span><span class="p">):</span>
        <span class="n">r_1</span> <span class="o">=</span> <span class="n">p_trans</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">val</span> <span class="o">=</span> <span class="n">p_exp</span><span class="p">(</span><span class="n">r_1</span><span class="p">,</span> <span class="o">.</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">t_bins</span><span class="p">):</span>
            <span class="n">kernel</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="k">return</span> <span class="n">kernel</span><span class="o">/</span><span class="n">kernel</span><span class="o">.</span><span class="nb">sum</span><span class="p">()</span>

<span class="n">kernel</span> <span class="o">=</span> <span class="n">make_kernel</span><span class="p">(</span><span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span><span class="p">)</span>
<span class="n">plot_disk</span><span class="p">(</span><span class="n">th</span><span class="p">,</span> <span class="n">r</span> <span class="p">,</span> <span class="n">kernel</span><span class="p">)</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_6_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># A function that returns the vertex areas</span>
<span class="k">def</span> <span class="nf">vertex_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">):</span>
    <span class="n">tri</span> <span class="o">=</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles</span><span class="p">]</span>
    <span class="n">tri_area</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">tri</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">tri</span><span class="p">[:,</span><span class="mi">2</span><span class="p">],</span> <span class="n">tri</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">tri</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]),</span> <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">6</span>
    <span class="n">A_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">mesh</span><span class="o">.</span><span class="n">triangles</span><span class="p">):</span>
        <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">,</span> <span class="n">t3</span> <span class="o">=</span> <span class="n">t</span>
        <span class="n">A_mat</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tri_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">A_mat</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tri_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">A_mat</span><span class="p">[</span><span class="n">t3</span><span class="p">]</span> <span class="o">+=</span> <span class="n">tri_area</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        
    <span class="k">return</span> <span class="n">A_mat</span>
    
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># A matrix containing the distance probabilities</span>
<span class="n">rho</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">p_bins</span><span class="p">))</span>
<span class="n">theta</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">t_bins</span><span class="p">))</span>
<span class="n">rho_o</span><span class="p">,</span> <span class="n">theta_o</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">rho</span><span class="p">,</span><span class="n">theta</span><span class="p">)</span>
<span class="n">rho</span><span class="p">,</span> <span class="n">theta</span> <span class="o">=</span> <span class="n">p_trans</span><span class="p">(</span><span class="n">rho_o</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="n">t_trans</span><span class="p">(</span><span class="n">theta_o</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">y1</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y2</span> <span class="o">=</span> <span class="p">(</span><span class="n">rho</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">([</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
<span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">80</span><span class="p">,</span><span class="mi">80</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

<span class="n">p_exp</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">y</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">80</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">80</span><span class="p">):</span>
        <span class="n">y1</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">y1</span> <span class="o">-</span> <span class="n">y2</span><span class="p">)</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_exp</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">.</span><span class="mi">3</span><span class="p">)</span>
    
<span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">/</span><span class="n">dist</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<p>To make use of ‘easy’ matrix multiplications. We make a matrix that contain the respective probablity and vertex area already. If $N$ is the number of vertices and $B$ the number of bins then the function below return a $N\times N \times B$ matrix.</p>

<p>This matrix contain for a vertex $i$ a matrix of size $N\times B$. In each column the values $p_{\rho,\theta}(y)\mu(y)$ are stored.</p>

<p>This $N\times B$ matrix should afterwards be multiplied on the left by $[f(v_1) \cdots f(v_n)]$ to get the patch function $[D_xf(b_1) \cdots D_xf(b_B)]$. For the convolution with the kernel the innerproduct with the kernel should be taken.</p>

<p>The order of multiplication can be changed for efficiency, incase you want the same kernel and many different function, or one function and many different kernels</p>

<p><strong>note</strong> This matrix is very sparse. Thus the code might benifit from sparse methods.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">big_prob_mat</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">adj_mat</span><span class="p">,</span> <span class="n">dist</span> <span class="o">=</span> <span class="n">dist</span><span class="p">):</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">adj_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">adj_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">//</span><span class="n">N</span>
    
    <span class="n">A_mat</span> <span class="o">=</span> <span class="n">vertex_area</span><span class="p">(</span><span class="n">mesh</span><span class="p">)</span>
    
    <span class="n">p_mat</span> <span class="o">=</span> <span class="n">adj_mat</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">,</span><span class="n">B</span><span class="p">))</span>
    
    <span class="c"># Insert the vertex areas</span>
    <span class="c"># [N,N,B] hadamard [1,N,1]</span>
    <span class="n">p_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">p_mat</span><span class="p">,</span> <span class="n">A_mat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
    
    <span class="c"># Insert the probabilities and normalise</span>
    <span class="c"># [N,N,B] [N,B,B] =&gt; [N,N,B]</span>
    <span class="n">p_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">p_mat</span><span class="p">,</span> <span class="n">dist</span><span class="p">)</span>
    <span class="n">p_mat</span> <span class="o">=</span> <span class="n">p_mat</span><span class="o">/</span><span class="n">p_mat</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">axis</span> <span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span> <span class="o">=</span> <span class="bp">True</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">p_mat</span>
</code></pre></div></div>

<hr />

<h1 id="example-1-the-sphere">Example 1: The Sphere</h1>

<p>In this example we take the isohedral sphere.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># open the mesh</span>
<span class="n">file_sphere</span> <span class="o">=</span> <span class="s">'../test_data/sphere_iso_6c.ply'</span>
<span class="n">sphere</span> <span class="o">=</span> <span class="n">trimesh_from_ply</span><span class="p">(</span><span class="n">file_sphere</span><span class="p">)</span>
</code></pre></div></div>

<p>The below function creates the adjacency matrix:
The innerworking can be described as</p>
<ul>
  <li>for each vertex do
    <ul>
      <li>find the points in a certain geodesic radius</li>
      <li>find for each of these points the geodesic</li>
      <li>bin each point in a angular and radial bin</li>
    </ul>
  </li>
  <li>return the matrix</li>
</ul>

<p>Right now the matrix has dimension NxNxPxT, where N are the number of vertices P the number of radial bins and T the number of angular bins.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make the adjacency matrix</span>
<span class="n">adj_sphere</span> <span class="o">=</span> <span class="n">adjacency_matrix_fmm</span><span class="p">(</span><span class="n">sphere</span><span class="p">,</span> <span class="n">p_max</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="n">p_bins</span> <span class="o">=</span> <span class="n">p_bins</span><span class="p">,</span> <span class="n">t_bins</span> <span class="o">=</span> <span class="n">t_bins</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100%|██████████| 642/642 [05:42&lt;00:00,  1.61it/s]
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make a sparse matrix out of the adjacenct matrix. </span>
<span class="n">sparse_sphere</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">csr_matrix</span><span class="p">(</span><span class="n">adj_sphere</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">),</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">time</span>
<span class="n">prob_mat</span> <span class="o">=</span> <span class="n">big_prob_mat</span><span class="p">(</span><span class="n">sphere</span><span class="p">,</span> <span class="n">sparse_sphere</span><span class="p">)</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU times: user 576 ms, sys: 205 ms, total: 780 ms
Wall time: 995 ms
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Our function has value 1 on a vertex and is zero otherwise.</span>
<span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">))</span>
<span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

<span class="c"># The convoluted function</span>
<span class="n">Df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">prob_mat</span><span class="p">)</span>
<span class="n">f_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">Df</span><span class="p">,</span> <span class="n">kernel</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Initial function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">sphere</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Convoluted function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">f_conv</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_18_0.png" alt="png" /></p>

<h1 id="example-2-the-body">Example 2: The body</h1>

<p>This example show a body traingulation of from the <a href="http://faust.is.tue.mpg.de">FAUST</a> dataset. This triangulation is a bit more irregular than the sphere.</p>

<p>We have already precomputed the adjacency matrix (hardbinning), to calculate this would take roughly one hour. To make the adjacency matrix we have used the following settings:</p>
<ul>
  <li><code class="highlighter-rouge">p_max = 0.03</code></li>
  <li><code class="highlighter-rouge">t_bins = 16</code></li>
  <li><code class="highlighter-rouge">p_bins = 5</code></li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">file_adj</span> <span class="o">=</span> <span class="s">'../test_data/tr_reg_004_raw.npz'</span>
<span class="n">file_body</span> <span class="o">=</span> <span class="s">'../test_data/tr_reg_004.ply'</span>

<span class="n">p_bins</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">t_bins</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">adj_mat</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">load_npz</span><span class="p">(</span><span class="n">file_adj</span><span class="p">)</span>
<span class="n">body</span> <span class="o">=</span> <span class="n">trimesh_from_ply</span><span class="p">(</span><span class="n">file_body</span><span class="p">)</span>
</code></pre></div></div>

<hr />

<p>We will use the same kernel. We will already precompute the matrix, so that we only need to multiply with the function in the end. The function that will be examined are a function similar to the case of the sphere and a more interesting function, namely and eigenfunction of the laplace beltrami operator.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">time</span>
<span class="n">prob_mat_body</span> <span class="o">=</span> <span class="n">big_prob_mat</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">adj_mat</span><span class="p">)</span>
<span class="n">p_kern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">prob_mat_body</span><span class="p">,</span><span class="n">kernel</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU times: user 1min 27s, sys: 1min 52s, total: 3min 19s
Wall time: 3min 4s
</code></pre></div></div>

<hr />

<p>First the function with $1$ on a vertex and zero elsewhere. In the end we see nice result, because the number of vertices here is more dense than in the case of the sphere it actually looks smoother.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ind</span> <span class="o">=</span> <span class="mi">500</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">6890</span><span class="p">)</span>
<span class="n">f</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">p_kern</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The function to make the images. </span>
<span class="c">#body.vtki_plot(ind = [ind], color = f)</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/conv_1.png" alt="png" height="720apx" width="360px" />
<img src="/assets/images/geodesic_convolution/conv_2.png" alt="png" height="720apx" width="360px" /></p>

<hr />

<h3 id="laplace-beltrami-eigenfunctions">Laplace Beltrami Eigenfunctions</h3>

<p>The function on which we will take the convolution is the an eigenvector of the laplace beltrami operator with added noise. The kernel will again be the gaussian kernel, ideally this kernel should be able to help with the noise that we added.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># get a laplace function</span>
<span class="n">val</span><span class="p">,</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">laplace_beltrami_eigenfunctions</span><span class="p">(</span><span class="n">body</span><span class="p">,</span><span class="n">k</span> <span class="o">=</span> <span class="mi">50</span><span class="p">)</span>

<span class="c"># To make sure we get the same result</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">laplace_func_orig</span> <span class="o">=</span> <span class="n">vec</span><span class="p">[:,</span><span class="mi">20</span><span class="p">]</span>
<span class="n">laplace_func</span> <span class="o">=</span> <span class="n">laplace_func_orig</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">scale</span> <span class="o">=</span> <span class="o">.</span><span class="mi">15</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">laplace_func_orig</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Original function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Noisy function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_30_0.png" alt="png" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">%%</span><span class="n">time</span>
<span class="c"># Apply the convolution</span>
<span class="n">f_conv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">matmul</span><span class="p">(</span><span class="n">laplace_func</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">p_kern</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU times: user 69.3 ms, sys: 5.28 ms, total: 74.6 ms
Wall time: 82.5 ms
</code></pre></div></div>

<hr />

<p>If we plot the convoluted function, we see a nice smoothing of the noise.</p>

<hr />

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Plotting the original and the convoluted function. </span>

<span class="n">plotter</span> <span class="o">=</span> <span class="n">vtki</span><span class="o">.</span><span class="n">Plotter</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

<span class="n">color_map</span> <span class="o">=</span> <span class="s">'jet'</span>

<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Original function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Noisy function'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">laplace_func</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
                 
<span class="n">plotter</span><span class="o">.</span><span class="n">subplot</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">polydata</span> <span class="o">=</span> <span class="n">PolyData</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[[[</span><span class="mi">3</span><span class="p">]]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">),</span><span class="n">body</span><span class="o">.</span><span class="n">triangles</span><span class="p">])</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_text</span><span class="p">(</span><span class="s">'Convolution'</span><span class="p">,</span> <span class="n">position</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">font_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">polydata</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">f_conv</span><span class="p">,</span> <span class="n">cmap</span> <span class="o">=</span> <span class="n">color_map</span><span class="p">)</span>
<span class="n">plotter</span><span class="o">.</span><span class="n">view_vector</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">viewup</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>


<span class="n">plotter</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_33_0.png" alt="png" /></p>

<hr />

<p>As an extra check to see that the convolution does what we expect we plot the function values, with their index on the xaxis. Note there is no guarentee that adjacent indices are neighbors or even close together. The convolution removes the noise in the function and becomes closer to the actual function. As we would expect.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span> <span class="o">=</span> <span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="mi">20</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">laplace_func</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Noisy'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Orig'</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">f_conv</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'convolution'</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">laplace_func_orig</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s">'Orig'</span><span class="p">,</span> <span class="n">linewidth</span> <span class="o">=</span> <span class="o">.</span><span class="mi">5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

</code></pre></div></div>

<p><img src="/assets/images/geodesic_convolution/output_35_1.png" alt="png" /></p>



        </div>
      </div>

    </body>
</html>
